# 零信任网络模型

## 大面儿

使用零信任网络模型是对云原生策略中的工作负载与主机进行加固的最佳实践。

## 价值

零信任网络具备足够的弹性，即便是在攻击者尝试破坏应用或基础设置时。它让攻击者举步维艰，还能让行为观测变得更加轻松。

我们这里讲的更换控制模型，拥抱这些玩意儿的企业不用搞什么漫长的应用升级就可以牢牢地对网络进行加固。安全团队可以成为商业价值的驱动因素，而不是绊脚石。

## 特性

这里我们用到了Calico的以下特性：

- **NetworkPolicy**以及**GlobalNetworkPolicy**：
    - 命名空间
    - RBAC
    - Service Account
- **HostEndpoint**
- 集成AWS安全组
- 为Istio提供应用层策略

## 概念

### 网络总是充满敌意

**零信任网络**是一种网络安全手段，它表达的潜台词就是假设网络总是充满敌意的。这就跟边缘及“分区”手段，关注如何将可信区域跟不可信区域分割开来的思路完全相反。

为什么要假设网络的敌对性？在很多攻击场景中，的确是这样。

- 攻击者攻破了网络设施中的“可信”组件：路由器、交换机、链接，等等。
- 有意或无意的错误配置会导致敏感流量被路由到不可信的网络上，例如公共互联网。
- “可信”网络中的其它端点也会遭到攻击：你的应用可能跟其它数千个服务器、数万个容器、数千个个人电脑、手机等，共处同一个网络。

大部分攻击都是从一个很小的点渗入进来的，但是攻击者随后就可以通过网络悄悄地找到一些价值更高的目标：你的公司或客户的数据。在一个区域化或边缘化的模型中，攻击者一旦攻破一个点，就在区域和边缘内随意溜达。零信任网络面对这种威胁依然具备弹性，因为它在所有网络连接上都施加了严格的、密码加密的认证和访问控制。

### 零信任网络的必要条件

零信任网络要求网络的访问控制达到特定条件：

**条件1：**所有网络连接都要服从要求（不光是跨区域边界）
**条件2：**建立远程端点的身份必须总是要基于多重标准，包括强密码加密的身份凭证。特别是网络级的标识符，例如IP地址和端口，并不充分，因为在一个有敌意的网络中它可能会被假冒。
**条件3：**所有期望的和被允许的网络流量都要被明确的允许才行。没有被明确允许的连接都要被拒绝。
**条件4：**被攻击的工作负载无法绕过策略机制。
**条件5：**许多零信任网络还要求网络流量加密，防止敏感数据被有敌意的网络嗅探拆包。如果私有数据并没有在网络中交换的话，这就不是一个必要条件，但是为了满足零信任网络标准，如果要加密，那么所有网络连接都得加密，要搞全搞。零信任网络不会区分可信和不可信的网络链接或路径。而且，即便没有用加密手段保护数据，仍然会需要密码加密的真实性凭据来建立身份。

### Calico和Istio如何实现零信任网络的要求

Calico与Istio服务网格协同作战，在Kubernetes集群中实现了需要构建零信任网络的一切条件。

#### 多个施加点

使用Istio时，进入到工作负载的请求会穿过两个不同的施加点：

1. 主机Linux内核。Calico策略使用iptables在Linux内核的L3-L4层中施加策略。
2. Envoy代理。Calico在Envoy代理的L3-L7层中施加策略，对请求进行加密认证。在这种场景中，会有一个轻量级的策略决策Sidecar——Dikastes——来辅助Envoy。

这里的多个施加点根据多重标准（条件2）建立了远程端点的身份。主机Linux内核的施加点能够保护你的工作负载，即便工作负载的Pod被攻破且Envoy代理被绕过了（条件4）。

#### Calico策略存储

保存在Calico数据存储中的策略编制了流量白名单（条件3）。

Calico网络策略被设计用于灵活适配多种不同的安全范式，因此它能表达例如零信任网络的白名单模式，也能够表达以前的那种区域化的范式。你甚至可以同时把它们应用在不同的层级上，用不着搞一大堆策略文档管理也麻烦。

本文后面会介绍如何编写零信任网络风格专用的策略。理论上来说，你首先要默认拒绝所有网络流量，然后添加规则，只允许那些应用需要的流量。搞完之后，只有合法的应用流量才会被允许，其他的就都拒掉了。

#### Calico控制面

Calico控制面将策略信息从Calico数据存储中分发到每一个施加点上，确保所有网络连接都符合要求（条件1）。它将高层声明式策略翻译成具体的施加点的属性，并伴随应用扩缩以及开发者的更改而一同变化以满足要求。

#### Istio Citadel身份系统

在Calico和Istio中，工作负载的身份是基于Kubernetes的Service Account的。其中有一个Istio组件叫Citadel，负责给每个Service Account创建密码加密的密钥，用以在网络中标明身份（条件2）以及流量加密（条件5）。这样就可以在即便是攻击者攻破了路由器或链接这种网络设施之后，依然能够保证零信任网络的弹性。

## 怎么弄

现在我们讲一下如何用Calico和Istio建立零信任网络。我们站在平台和安全工程师的角度来进行讲解，但是对于开发者来说也同样有助于理解整个过程。

打造并维护一个零信任网络是整个应用交付团队的工作，也就是说为用户交付一个网络应用涉及到了每一个人。其中包括：

- 开发者、DevOps、运维
- 平台工程师
- 网络工程师
- 安全工程师以及安全操作员

特别是站在开发者的角度，把应用开发完了交给别人去研究如何加固，这就跟零信任网络策略穿不到一条裤子里。为了让一切良好运转，一个零信任网络需要根据详细的期望流量来配置——只有开发者清楚。

站在更高的角度来看，你应该按照以下步骤建立一个零信任网络：

1. 安装Calico。
2. 安装Istio并启用Calico集成。
3. 用ServiceAccount建立工作负载身份。
4. 给每个服务编写初始的白名单策略。

零信任网络建立之后，你需要对它进行维护。

### 安装Calico

按照[安装指引](../02%E5%AE%89%E8%A3%85Calico/01Kubernetes/00Kubernetes.md)进行安装。

### 安装Istio并启用Calico集成

参照[启用应用层策略](07Istio的策略/01%E4%B8%BAIstio%E6%96%BD%E5%8A%A0%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5.md)进行操作。

其中包括一个Istio安装的“demo”，可以进行快速验证。如果是生产环境部署零信任网络，应该按照Istio的官网文档进行安装。确保在安装选项中把**global.mtls.enabled**设置成了**true**，开启双向TLS（mTLS）认证。

### 用ServiceAccount建立工作负载身份

我们最终的目标是编写访问控制策略来为每一个期望的网络流量进行授权。我们希望这些流量紧切实际。在一个Calico的零信任网络中，加密身份就是Kubernetes的Service Account。Istio为你处理加密密钥的管理，这样每个工作负载就可以安全的坚持它的Service Account身份。

在零信任网络策略中，身份的分配也具备一定的灵活性。对于大部分人来说，一种比较好的平衡是给每个Kubernetes Service（如果不接受任何请求的话那就是Deployment）一个唯一的身份。直接给整个应用或命名空间一个身份的话就太粗糙了，一个应用通常是由多个服务（或大量的微服务）组成的，每个服务的实际需求都是不同的。

即便你知道这些微服务访问的都是一样的东西，那也应该分别赋予唯一的身份。当你把身份跟应用的逻辑组件对应起来，策略的可读性也会很好。你可以给这些策略赋予同样的权限，后面如果需要不同的权限，处理起来就很方便了。

当你确认了你需要的身份集合，然后就要创建Kubernetes的Service Account，然后再修改应用配置，让每个Deployment、ReplicaSet、StatefulSet等等，使用正确的Service Account。

### 给每个服务编写初始的白名单策略

最后就是给每个服务写策略了。在[应用层网络策略](07Istio的策略/03%E6%A0%B9%E6%8D%AEIstio%E7%9A%84%E6%95%99%E7%A8%8B%E6%9D%A5%E6%96%BD%E5%8A%A0%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5.md)中介绍了如何根据Service Account身份来建立流量管理策略。

对于每个服务你需要：

- 判定有哪些其它身份会访问这个服务。
- 添加规则允许这些流量。

当一个Pod被某个策略选中后，不在白名单内的流量就会被拒绝。这就实现了零信任网络范式要求的白名单模式。

### 判定需要访问服务的所有身份

有若干种方法可以判定这个事儿。跟应用开发者一起坐下来聊聊，是吧，把这个列表好好定下来。一种方法就是给整个应用画一个数据流图。数据流图中的每个身份就是一个节点，每个期望的流量就是一条边。

看个例子。

![img](https://projectcalico.docs.tigera.io/images/zero-trust-app.png)

用户发起的所有请求都会经过一个api服务，然后它会调用其它后端的服务。然后依次调用其它服务。图中每个箭头都是一个期望的流量，如果两个服务没有箭头相连，那么理论上它们之间就是不存在网络通信的。比如只有api和search服务会调用post服务。

对于简单的应用来说，特别是那种单一团队维护的应用，开发者可能凭印象或者大概扫一眼代码就能画出这个图了。

如果凭印象画不出来，你有这么几个选择。

1. 在测试环境带上策略跑一下这个应用。
    1. 看看服务日志里有没有报错的连接。
    2. 添加规则放行报错的连接，直到程序完全正常。
    3. 继续看下一个服务，直到检查完所有的服务。
2. 收集应用实例的实时流量日志。企业版的Tigera Secure可以帮你搞定这个事儿，或者是Istio带的Kiali面板。
    1. 分析日志并判定流量集合。
    2. 检查日志中的流量，为期望的流量添加放行规则。
3. 使用企业版Tigera Secure，调成logging-only模式。
    1. 在这种模式下“拒绝”的连接只会被记录下来而不是真的拒绝掉。
    2. 检查“拒绝”日志，为期望的流量添加放行规则。

当你基于一个运行中的应用实例来判定流量时，记得跟开发者一同审查你添加的每一条规则，确保它是合法且期望的流量。你最不想看到的就是在策略中把一个正在攻击的流量当成期望流量了！